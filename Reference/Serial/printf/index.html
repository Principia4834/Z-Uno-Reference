<span zunoVersion="v2"></span>
<h2>printf()</h2>
<span class="function_description">Функция для форматированного вывода текста.</span>

<span class="function_syntax">
<br>Serial.printf(*format)</br>
</span>

<span class="function_parameters">
	<span class="function_parameters_param">
		<span class="function_parameters_param_name">format:</span>
		<span class="function_parameters_param_description"><br>
			<ul>
				<li>
					<b>Format of the format string:</b><br>
			The format string is a character string, beginning and ending in its initial shift state, if any.   The  format  string  is
			composed of zero or more directives: ordinary characters (not %), which are copied unchanged to the output stream; and con‐
			version specifications, each of which results in fetching zero or more subsequent arguments.  Each conversion specification
			is  introduced  by  the character %, and ends with a conversion specifier.  In between there may be (in this order) zero or
			more flags, an optional minimum field width, an optional precision and an optional length modifier.
		
			The arguments must correspond properly (after type promotion) with the conversion specifier.  By default, the arguments are
			used  in  the  order given, where each '*' (see Field width and Precision below) and each conversion specifier asks for the
			next argument (and it is an error if insufficiently many arguments are given).  One can also specify explicitly which argu‐
			ment is taken, at each place where an argument is required, by writing "%m$" instead of '%' and "*m$" instead of '*', where
			the decimal integer m denotes the position in the argument list of the desired argument, indexed starting from 1.  Thus,<br>
			<br>
			    printf("%*d", width, num);<br>
				<br>
			and<br>
			<br>
			    printf("%2$*1$d", width, num);<br>
				<br>
			are equivalent.  The second style allows repeated references to the same argument.  The C99 standard does not  include  the
			style  using '$', which comes from the Single UNIX Specification.  If the style using '$' is used, it must be used through‐
			out for all conversions taking an argument and all width and precision arguments, but it may be mixed  with  "%%"  formats,
			which  do  not  consume an argument.  There may be no gaps in the numbers of arguments specified using '$'; for example, if
			arguments 1 and 3 are specified, argument 2 must also be specified somewhere in the format string.
				</li>
				<li>
					<b>Flag characters:</b><br>
The character % is followed by zero or more of the following flags:<br>
<br>
#      The  value  should be converted to an "alternate form".  For o conversions, the first character of the output string is made zero (by prefixing a 0 if it was not zero already).  For x and X conversions, a nonzero result has the string "0x" (or "0X" for X con‐
versions) prepended to it.  For a, A, e, E, f, F, g, and G conversions, the result will always contain a decimal point, even if no digits follow it (normally, a decimal point appears in the results of those conversions only if a digit follows).  For g  and  G
conversions, trailing zeros are not removed from the result as they would otherwise be.  For other conversions, the result is undefined.<br>
<br>
0      The  value should be zero padded.  For d, i, o, u, x, X, a, A, e, E, f, F, g, and G conversions, the converted value is padded on the left with zeros rather than blanks.  If the 0 and - flags both appear, the 0 flag is ignored.  If a precision is given with a
		numeric conversion (d, i, o, u, x, and X), the 0 flag is ignored.  For other conversions, the behavior is undefined.<br>
		<br>
-      The converted value is to be left adjusted on the field boundary.  (The default is right justification.)  The converted value is padded on the right with blanks, rather than on the left with blanks or zeros.  A - overrides a 0 if both are given.<br>
<br>
' '    (a space) A blank should be left before a positive number (or empty string) produced by a signed conversion.<br>
<br>
+      A sign (+ or -) should always be placed before a number produced by a signed conversion.  By default, a sign is used only for negative numbers.  A + overrides a space if both are used.<br>
<br>
The five flag characters above are defined in the C99 standard.  The Single UNIX Specification specifies one further flag character.<br>
<br>
'      For decimal conversion (i, d, u, f, F, g, G) the output is to be grouped with thousands' grouping characters if the locale information indicates any.  (See setlocale(3).)  Note that many versions of gcc(1) cannot parse this option and will  issue  a  warning.
(SUSv2 did not include %'F, but SUSv3 added it.)<br>
				</li>
			</ul>
		</span>
	</span>
</span>
<span class="function_returns">
    size_t (long): println() returns the number of bytes written, though reading that number is optional
</span>
<span class="function_example">
    <pre>
        <code class="c">int analogValue = 0;    // variable to hold the analog value

void setup() {
  // open the serial port at 115200 bps:
  Serial.begin();
}

void loop() {
  // read the analog input on pin 0:
  analogValue = analogRead(0);

  // print it out in many formats:
  Serial.println(analogValue);       // print as an ASCII-encoded decimal
  Serial.println(analogValue, DEC);  // print as an ASCII-encoded decimal
  Serial.println(analogValue, HEX);  // print as an ASCII-encoded hexadecimal
  Serial.println(analogValue, OCT);  // print as an ASCII-encoded octal
  Serial.println(analogValue, BIN);  // print as an ASCII-encoded binary

  // delay 10 milliseconds before the next reading:
  delay(10);
}
